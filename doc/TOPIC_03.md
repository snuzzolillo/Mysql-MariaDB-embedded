## The Bind Variables
Bind Variables are used to exchange data between the host language and the embedded language. For the purposes of this pre-compiler, it will make a direct relationship between variables in embedded language (those preceded with ":") and variables (of global context) within the host language with a correlation by "name of variable", that is, a variable called "*:var_date*" in the embedded language the value will be associated with a variable called "*$var_date*" in the host language.

Let's look at this example of embedded SQL code:
```php
	/*<MARIADB ANONYMOUS CASE2>
	-- --------------------------------------------------------------------
	-- Testing with MARIADB, version 10.1.29
	-- --------------------------------------------------------------------
	
	  DECLARE in_date date DEFAULT null;
	  set in_date = DATE_ADD(:var_date, INTERVAL 30 DAY);
	  
	  set :var_test = 'any value';
	  set :var_date = in_date;
	<END>*/
```

In this example there are two Bind Variable, called "*:var_date*" and "*:var_test*". The precompiler assumes that they will be related to global context php variables called  "*\$var\_date*" and "*\$var\_test*" respectively. Additionally, the values of "*:var_date*" and "*:var_test*" are modified by assignment statements.

The handling of the Bind Variables has two phases:
 1. Assignment from the host language to the embedded language as an initialization.
 2. Reassignment of the value from the embedded
    language to the host language.
To do this the precompiler generates the necessary instructions that we will see later.

To execute the embedded code of the example from php, we would follow these steps:
```
## Setting values to Bind Variables
$var_date = '2018/01/01'; # Used as Bind Variable

## Execute generated code
$parser->doCode('CASE2');

echo 'var_date='.$var_date.'<br>';
echo 'var_test='.$var_test;
```
OUTPUT:
```
var_date=2018-01-31
var_test=any value
```
Note that "*$var_test*" was not initialized. The precompiler creates the php variable if it has not been created yet, the creation always occurs within the global context. For these variables created by the precompiler the initial value is "" for php, NULL for SQL.

##### Case-insensitive name correspondence problem.
The code generated by the precompiler handles the Bind Variable in a case-insesitive way. This could cause some problems if we do not take due care. Let's look at an example to understand the problem:
```
/*<MARIADB ANONYMOUS CASE3>
SET :VAR = 4;
SET :var = 1;
SET :Var = 2;
SET :VAr = 3;
<END>*/
```
For the purposes of the embedded code, the 4 cases shown refer to the same Bind Variable (for SQL it is a session variable called @VAR), but the precompiler has made a correspondence relation with 4 different php variables that are:
```
$var
$Var
$VAr
$VAR
```
Remember that if the precompiler does not find an exact correspondence of a variable name in php, it will create the variables within the global context, this means that, after execution of the embedded code, the 4 variables exist within php and all will have the last value that was assigned to @VAR (in this example all 4 variables will have de value of '3').

##### Seting and Rassigning Values from-to Bind Variables
Initial values without initialization from PHP

|PHP ASSIGNEMENT|PRECOMPILER BUILD CODE|
|--|--|
|NONE|SET @VAR = NULL; -- Create $VAR|
|NONE|SET @VAR = NULL; -- Create $var|
|NONE|SET @VAR = NULL; -- Create $Var|
|NONE|SET @VAR = NULL; -- Create $VAr|

Initial values with initialization from PHP

|PHP ASSIGNEMENT|PRECOMPILER BUILD CODE|
|--|--|
|$VAR = 7;|SET @VAR = '7'; -- Get Value from $VAR|
|$var = 4;|SET @VAR = '4'; -- Get Value from $var|
|$Var = 5;|SET @VAR = '5'; -- Get Value from $Var|
|$VAr = 6;|SET @VAR = '6'; -- Get Value from $VAr|

Returning Values

|PRECOMPILER BUILD CODE|PHP AFTER EXECUTION ASSIGNAMENT|
|--|--|
|SELECT|Reassign from ARRAY RESULT|
|	 'OUTPUT BIND' as \_\_\_action\_\_\_|$_\_\_action___ = array['\_\_\_action\_\_\_']; // OUTPUT BIND
|	,@VAR as VAR|$VAR = array['VAR']; // Last Value of @VAR = 4|
|	,@VAR as var|$var = array['var']; // Last Value of @VAR = 4|
|	,@VAR as Var|$Var = array['Var']; // Last Value of @VAR = 4|
|	,@VAR as VAr;|$VAr = array['VAr']; // Last Value of @VAR = 4|
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNjE5Njk3MzVdfQ==
-->